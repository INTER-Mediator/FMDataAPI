<?php

namespace INTERMediator\FileMakerServer\RESTAPI\Supporting;

use Iterator;

/**
 * Class FileMakerRelation is the record set of queried data. This class implements Iterator interface.
 * The object of this class is going to be generated by the FileMakerLayout class,
 * and you shouldn't call the constructor of this class.
 *
 * @package INTER-Mediator\FileMakerServer\RESTAPI
 * @link https://github.com/msyk/FMDataAPI GitHub Repository
 * @property string $<<field_name>> The field value named as the property name.
 * @property FileMakerRelation $<<portal_name>> FileMakerRelation object associated with the property name.
 *    The table occurrence name of the portal can be the 'portal_name,' and also the object name of the portal.
 * Ver * @version 31
 * @author Masayuki Nii <nii@msyk.net>
 * @copyright 2017-2023 Masayuki Nii (Claris FileMaker is registered trademarks of Claris International Inc. in the U.S. and other countries.)
 */
class FileMakerRelation implements Iterator
{
    /**
     * @var null|object
     * @ignore
     */
    private null|array|object $data;
    /**
     * @var null|object
     * @ignore
     */
    private mixed $dataInfo;
    /**
     * @var null|string
     * @ignore
     */
    private ?string $result; // OK for output from API, RECORD, PORTAL, PORTALRECORD
    /**
     * @var int|null
     * @ignore
     */
    private ?int $errorCode;
    /**
     * @var int
     * @ignore
     */
    private int $pointer = 0;
    /**
     * @var string|null
     * @ignore
     */
    private ?string $portalName;
    /**
     * @var null|CommunicationProvider The instance of the communication class.
     * @ignore
     */
    private ?CommunicationProvider $restAPI;

    /**
     * FileMakerRelation constructor.
     *
     * @param array<object> $responseData
     * @param object|array $infoData
     * @param string $result
     * @param int $errorCode
     * @param string|null $portalName
     * @param CommunicationProvider|null $provider
     *
     * @ignore
     */
    public function __construct(array|object $responseData, object|array $infoData, string $result = "PORTAL",
                                int   $errorCode = 0, ?string $portalName = null, CommunicationProvider $provider = null)
    {
        $this->data = $responseData;
        $this->dataInfo = $infoData;
        $this->result = $result;
        $this->errorCode = $errorCode;
        $this->portalName = $portalName;
        $this->restAPI = $provider;
        if ($errorCode === 0 && $portalName && is_array($infoData)) {
            foreach ($infoData as $pdItem) {
                if (property_exists($pdItem, 'portalObjectName') && $pdItem->portalObjectName == $portalName ||
                    !property_exists($pdItem, 'portalObjectName') && $pdItem->table == $portalName) {
                    $this->dataInfo = $pdItem;
                }
            }
        }
    }

    /**
     * @ignore
     */
    public function getDataInfo()
    {
        return $this->dataInfo;
    }

    /**
     * Get the table occurrence name of a query to get this relation.
     *
     * @return null|string The table occurrence name.
     */
    public function getTargetTable(): null|string
    {
        return ($this->dataInfo) ? $this->dataInfo->table : null;
    }

    /**
     * Get the total record count of a query to get this relation.
     * Portal relation doesn't have this information and returns NULL.
     *
     * @return null|int The total record count.
     */
    public function getTotalCount(): null|int
    {
        return ($this->dataInfo && property_exists($this->dataInfo, 'totalRecordCount')) ?
            $this->dataInfo->totalRecordCount : null;
    }

    /**
     * Get the founded record count of a query to get this relation.
     * If the relation comes from getRecord() method,
     * this method returns 1.
     *
     * @return null|int The founded record count.
     */
    public function getFoundCount(): null|int
    {
        return ($this->dataInfo) ? $this->dataInfo->foundCount : null;
    }

    /**
     * Get the returned record count of a query to get this relation.
     * If the relation comes from getRecord() method,
     * this method returns 1.
     *
     * @return null|int The returned record count.
     */
    public function getReturnedCount(): null|int
    {
        return ($this->dataInfo) ? $this->dataInfo->returnedCount : null;
    }

    /**
     * If the portal name is different with the name used as the portal referencing name, this method can set it.
     *
     * @param string $name The portal name.
     */
    public function setPortalName(string $name): void
    {
        $this->portalName = $name;
    }

    /**
     * The record pointer goes back to the previous record. This does not care the range of pointer value.
     */
    public function previous(): void
    {
        $this->pointer--;
    }

    /**
     * The record pointer goes forward to the previous record. This does not care the range of pointer value.
     */
    public function next(): void
    {
        $this->pointer++;
    }

    /**
     * The record pointer goes to the first record.
     */
    public function last(): void
    {
        $this->pointer = count($this->data) - 1;
    }

    /**
     * The record pointer goes to the specified record.
     *
     * @param int $position The position of the record. The first record is 0.
     */
    public function moveTo(int $position): void
    {
        $this->pointer = $position - 1;
    }

    /**
     * Count the number of records.
     * This method is defined in the Iterator interface.
     *
     * @return int The number of records.
     */
    public function count(): int
    {
        return match ($this->result) {
            "OK", "PORTAL" => count($this->data),
            "RECORD", "PORTALRECORD" => 1,
            default => 0,
        };
    }

    /**
     * @param $key
     *
     * @return FileMakerRelation|string|null
     * @throws Exception
     * @ignore
     */
    public function __get($key)
    {
        return $this->field($key);
    }

    /**
     * Return the array of field names.
     *
     * @return array List of field names
     */
    public function getFieldNames(): array
    {
        $list = [];
        if (isset($this->data)) {
            switch ($this->result) {
                case 'OK':
                    if (isset($this->data[$this->pointer]->fieldData)) {
                        foreach ($this->data[$this->pointer]->fieldData as $key => $val) {
                            $list[] = $key;
                        }
                    }
                    break;
                case 'PORTAL':
                    if (isset($this->data[$this->pointer])) {
                        foreach ($this->data[$this->pointer] as $key => $val) {
                            $list[] = $key;
                        }
                    }
                    break;
                case 'RECORD':
                    if (isset($this->data->fieldData)) {
                        foreach ($this->data->fieldData as $key => $val) {
                            $list[] = $key;
                        }
                    }
                    break;
                default:
            }
        }

        return $list;
    }

    private function getNumberedRecord($num): ?FileMakerRelation
    {
        $value = null;
        if (isset($this->data[$num])) {
            $tmpInfo = $this->getDataInfo();
            $dataInfo = null;
            if ($tmpInfo !== null && is_object($tmpInfo)) {
                $dataInfo = clone $tmpInfo;
                $dataInfo->returnedCount = 1;
            }
            $value = new FileMakerRelation(
                $this->data[$num], $dataInfo, ($this->result == "PORTAL") ? "PORTALRECORD" : "RECORD",
                $this->errorCode, $this->portalName, $this->restAPI);
        }
        return $value;
    }

    /**
     * Returns the fiest record of the query result.
     *
     * @return FileMakerRelation|null The record set of the record.
     */
    public function getFirstRecord(): ?FileMakerRelation
    {
        return $this->getNumberedRecord(0);
    }

    /**
     * Returns the last record of the query result.
     *
     * @return FileMakerRelation|null The record set of the record.
     */
    public function getLastRecord(): ?FileMakerRelation
    {
        return $this->getNumberedRecord(count($this->data) - 1);
    }

    /**
     * Returns the array of the query result. Usually iterating by using foreach is a better way.
     *
     * @return array The FileMakerRelation objects of the records.
     */
    public function getRecords(): array
    {
        $records = [];
        foreach ($this as $record) {
            $records[] = $record;
        }
        return $records;
    }

    /**
     * Export to array
     *
     * @return array
     */
    public function toArray(): array
    {
        switch ($this->result) {
            case 'OK':
            case 'PORTAL':
                $resultArray = [];
                foreach ($this as $record) {
                    $resultArray[] = $record->toArray();
                }
                return json_decode(json_encode($resultArray), true);
                break;
            case 'PORTALRECORD':
                if (isset($this->data)) {
                    return json_decode(json_encode($this->data), true);
                }
                break;
            case 'RECORD':
                if (isset($this->data->fieldData)) {
                    return json_decode(json_encode($this->data->fieldData), true);
                }
                break;
        }
        return [];
    }

    /**
     * Return the array of portal names.
     *
     * @return array List of portal names
     */
    public function getPortalNames(): array
    {
        $list = [];
        if (isset($this->data)) {
            switch ($this->result) {
                case 'OK':
                    foreach ($this->data as $key) {
                        if (property_exists($key, 'portalData')) {
                            foreach ($key->portalData as $name => $val) {
                                $list[] = $name;
                            }
                            break 2;
                        }
                    }
                    break;
                case 'RECORD':
                    if (property_exists($this->data, 'portalData')) {
                        foreach ($this->data->portalData as $name => $val) {
                            $list[] = $name;
                        }
                    }
            }
        }
        return $list;
    }

    /**
     * The field value of the first parameter.
     * Or the FileMakerRelation object associated with the first parameter.
     *
     * @param string $name The field or portal name.
     * The table occurrence name of the portal can be the portal name, and also the object name of the portal.
     * @param string|null $toName The table occurrence name of the portal as the prefix of the field name.
     *
     * @return string|FileMakerRelation The field value as string, or the FileMakerRelation object of the portal.
     * @throws Exception The field specified in parameters doesn't exist.
     * @see FMDataAPI::setFieldHTMLEncoding() Compatible mode for FileMaker API for PHP.
     *
     */
    public function field(string $name, string $toName = null): string|FileMakerRelation
    {
        $toName = is_null($toName) ? "" : "{$toName}::";
        $fieldName = "{$toName}$name";
        $value = null;
        if (isset($this->data)) {
            switch ($this->result) {
                case "OK":
                    if (isset($this->data[$this->pointer])) {
                        if (isset($this->data[$this->pointer]->fieldData->$name)
                        ) {
                            $value = $this->data[$this->pointer]->fieldData->$name;
                        } else if (isset($this->data[$this->pointer]->portalData->$name)
                        ) {
                            $infoData = property_exists($this->data[$this->pointer], 'portalDataInfo') ?
                                $this->data[$this->pointer]->portalDataInfo : null;
                            $value = new FileMakerRelation($this->data[$this->pointer]->portalData->$name,
                                $infoData, "PORTAL", 0, $name, $this->restAPI);
                        }
                    }
                    break;
                case "PORTAL":
                    if (isset($this->data[$this->pointer]->$fieldName)
                    ) {
                        $value = $this->data[$this->pointer]->$fieldName;
                    }
                    break;
                case "RECORD":
                    if (isset($this->data->fieldData->$name)) {
                        $value = $this->data->fieldData->$name;
                    } else if (isset($this->data->portalData->$name)) {
                        $infoData = property_exists($this->data, 'portalDataInfo') ? $this->data->portalDataInfo : null;
                        $value = new FileMakerRelation($this->data->portalData->$name, $infoData,
                            "PORTAL", 0, $name, $this->restAPI);
                    } else if (isset($this->data->fieldData->$fieldName)) {
                        $value = $this->data->fieldData->$fieldName;
                    }
                    break;
                case "PORTALRECORD":
                    $convinedName = "{$this->portalName}::{$fieldName}";
                    if (isset($this->data->$fieldName)) {
                        $value = $this->data->$fieldName;
                    } else if (isset($this->data->$convinedName)) {
                        $value = $this->data->$convinedName;
                    }
                    break;
                default:
            }
        }
        if (is_null($value)) {
            throw new Exception("Field {$fieldName} doesn't exist.");
        }
        if ($this->restAPI && $this->restAPI->fieldHTMLEncoding && !is_object($value)) {
            $value = htmlspecialchars($value);
        }
        return $value;
    }

    /**
     * Return the value of special field recordId in the current pointing record.
     *
     * @return int The value of special field recordId.
     */
    public function getRecordId(): int
    {
        $value = null;
        switch ($this->result) {
            case "OK":
                if (isset($this->data[$this->pointer])) {
                    if (isset($this->data[$this->pointer]->recordId)
                    ) {
                        $value = $this->data[$this->pointer]->recordId;
                    }
                }
                break;
            case "PORTAL":
                if (isset($this->data[$this->pointer]->recordId)
                ) {
                    $value = $this->data[$this->pointer]->recordId;
                }
                break;
            case "RECORD":
            case "PORTALRECORD":
                if (isset($this->data->recordId)) {
                    $value = $this->data->recordId;
                }
                break;
        }

        return $value;
    }

    /**
     * Return the value of special field modId in the current pointing record.
     *
     * @return int The value of special field modId.
     */
    public function getModId(): int
    {
        $value = null;
        switch ($this->result) {
            case "OK":
                if (isset($this->data[$this->pointer])) {
                    if (isset($this->data[$this->pointer]->modId)
                    ) {
                        $value = $this->data[$this->pointer]->modId;
                    }
                }
                break;
            case "PORTAL":
                if (isset($this->data[$this->pointer]->modId)
                ) {
                    $value = $this->data[$this->pointer]->modId;
                }
                break;
            case "RECORD":
            case "PORTALRECORD":
                if (isset($this->data->modId)) {
                    $value = $this->data->modId;
                }
                break;
        }

        return $value;
    }

    /**
     * Return the base64 encoded data in container field with streaming interface. The access with
     * streaming url depends on the setCertValidating(_) call, and it can work on self-signed certificate as a default.
     * Thanks to 'base64bits' as https://github.com/msyk/FMDataAPI/issues/18.
     *
     * @param string $name The container field name.
     * The table occurrence name of the portal can be the portal name, and also the object name of the portal.
     * @param string|null $toName The table occurrence name of the portal as the prefix of the field name.
     *
     * @return string|null The base64 encoded data in container field.
     * @throws Exception
     */
    public function getContainerData(string $name, ?string $toName = null): ?string
    {
        $fieldValue = $this->field($name, $toName);
        if (!str_starts_with($fieldValue, "https://")) {
            throw new Exception("The field '{$name}' is not field name or container field.");
        }
        return $this->restAPI->accessToContainer($fieldValue);
    }

    /**
     * Return the current element. This method is implemented for Iterator interface.
     *
     * @return FileMakerRelation|null The record set of the current pointing record.
     */
    public function current(): ?FileMakerRelation
    {
        $value = null;
        switch ($this->result) {
            case "OK":
            case "PORTAL":
                if (isset($this->data[$this->pointer])) {
                    $tmpInfo = $this->getDataInfo();
                    $dataInfo = null;
                    if (is_object($tmpInfo)) {
                        $dataInfo = clone $tmpInfo;
                        $dataInfo->returnedCount = 1;
                    }
                    $result = ($this->result == "PORTAL") ? "PORTALRECORD" : "RECORD";
                    $portalName = $this->portalName;
                    $value = new FileMakerRelation($this->data[$this->pointer], $dataInfo, $result,
                        $this->errorCode, $portalName, $this->restAPI);
                }
                break;
            case "RECORD":
            case "PORTALRECORD":
                $value = $this;
                break;
        }
        return $value;
    }

    /**
     * Return the key of the current element. This method is implemented for Iterator interface.
     *
     * @return integer The current number as the record pointer.
     */
    public function key(): int
    {
        return $this->pointer;
    }

    /**
     * Checks if current position is valid. This method is implemented for Iterator interface.
     *
     * @return bool Returns true on existing the record or false on not existing.
     */
    public function valid(): bool
    {
        switch ($this->result) {
            case "OK":
            case "PORTAL":
                if (isset($this->data[$this->pointer])) {
                    return true;
                }
                break;
            case "RECORD":
            case "PORTALRECORD":
                return $this->pointer == 0;
                break;
        }
        return false;
    }

    /**
     * Rewind the Iterator to the first element. This method is implemented for Iterator interface.
     */
    public function rewind(): void
    {
        $this->pointer = 0;
    }
}
